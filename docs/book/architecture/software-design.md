---
outline: deep
---

# 软件设计: 从专业到卓越

## 前言

**形成团队设计共识**: 软件开发是集体活动。团队如果缺乏设计共识，设计出的代码就不可能易于扩展、易于维护，可能还会在具体的解决方案设计上产生不必要的摩擦。

## 品味篇

优秀代码的特征：

- **外部特征**：是高质量代码应有的外在表现，从结果角度衡量。对这些特征的判断无须深入代码，即使是一个不懂软件的人，也能从外部感知到。
- **内部特征**：体现了代码是否“专业”，从代码的内部质量角度衡量。经验丰富的软件工程师，只需要大致读一下代码，就能感知到代码的大致质量

### 第 1 章 优质代码的外部特征

外部特征可以概括为以下 5 条：

1. 实现了期望的功能
2. 缺陷尽量少
3. 易于理解
4. 易于演进
5. 易于复用

其中前两条与代码外部质量有关，关注当下的效益。后 3 条和代码的演进有关，关注长期的价值。

#### 期望实现

Q：为什么实现期望的功能难？
A：用户真正需要的和用户描述的往往并不一致，经过层层加工，信息更是进一步失真，最终不仅成本大量超出预算，所开发的东西也不能真正满足用户的需要。

开发软件的过程是一个持续建立认知的过程。我们不能寄希望于业务人员一开始就对问题有直达本质的认知，随着开发过程的展开，渐渐地弄明白问题是很正常的。同样，我们也不能寄希望于开发人员一开始就能有直达本质的解决方案，随着开发过程的展开，渐渐地弄明白方案也是正常的。

有价值的软件需要关注的两个方面：

- 加快认知的过程
- 增加设计弹性，在出现问题时能较快调整

**优秀的开发者会关注自己开发的软件的真正价值，而不只是盲目地接收到手的需求。**

优秀的软件工程师往往也是沟通的高手，尊重他人、认真理解对方意图、准确达成一致方面。

如果软件设计得足够好，那么完全可以在用户需求发生变化时随机应变。

#### 缺陷少

关于软件缺陷的两个事实：

- 缺陷不可能完全避免；
- 缺陷带来的影响和发现缺陷的时机密切相关，要规避缺陷造成的影响，最重要的原则是尽量早地发现缺陷；

缺陷并不可怕，真正可怕的是没有能力及时发现缺陷。我们要做的不是要规避缺陷，而是要通过加快反馈，在缺陷造成实质性影响之前，就把它消灭于无形。

缺陷的应对策略：

- 缩短缺陷的发现周期：测试先行
- 降低缺陷的发现成本和修复成本：自动化测试
- 缩小缺陷的影响面：通过把软件划分为更合理的设计单元 ，定义清楚设计单元之间的依赖、接口和契约 ，并采取契约式设计等手段，就可以起到防火墙的效果，从而降低缺陷带来的影响

#### 易于理解

辻算机程序首先是用来给人读的，只是顺便用于机器执行。

高质量的软件设计一定会刻意且安全地隐藏细节，从而提升代码的可理解性。

代码的设计结构应该最大化地降低理解负担、尽量减少阅读代码的必要性。例如，让工程师：

- 能通过阅读 API 声明去理解代码，就不要去阅读 API 是如何实现的;
- 能通过观察代码结构 (如类名、包名、方法名)去理解代码，就不需要去阅读代码的内部实现；
- 能通过阅读直接理解代码，就不需要去阅读文档和注释；

降低代码的复杂性，是提升代码可理解性的关键，和许多编程实践密切相关：

- 更好的命名
- 一致的业务概念
- 更好的结构设计
- 尽量减少不必要的设计元素
- 减少重复
- 增加设计契约和**测试的描述能力**

凡是能真正把他人怎么阅读代码放在心上的软件工程师，即使一开始不具备非常好的设计技巧，随着时间的推移，也能很快学会这些技巧。**心中有他人是非常重要的意识和素养**，一个例子就是结对编程。

#### 易于演进

软件在实现了早期功能之后，并不会停止“生长”，而是会在后续的业务发展中被持续注入新的功能或者放入新的使用场景中。

为演进而设计：

- 良好的设计结构：好的设计，能够把那些似乎藕断丝连的逻辑巧妙地分解开，形成正交的设计，让它们互不影响。正交设计是增强代码演进能力最重要的手段，下面是一些好的设计原则：
  - 观察设计中相关因素的变化频率，把容易变化和不容易变化的部分分开，就能减少变化的影响
  - 根据变化的方向来识别设计对象的职责，这就是面向对象设计中的单一职责原则
  - 开闭原则
- 自动化测试
- 简单设计：要警惕一种可能会伤害到设计演进能力的“前瞻性设计”做法，即为未来所做的“预留设计”，这种错误的设计方式，也被称为过度设计或大规模预先设计

#### 易于复用

软件是信息制品，信息制品的典型特点是复用的边际成本极低。选择合适的复用粒度，定义清晰的设计职责和设计契约并很好地管理依赖，是提升代码复用能力的重要手段。

复用粒度越大，复用价值也就越大，不过复用的机会往往更小。

时至今日，业务模块的复用已经有了更好的理论基础，而且经过了实践的检验，这就是以领域为中心的设计。

可靠的复用必须满足两个条件：

1. 被复用模块的职责必须清晰，这样别人才可以知道该不该复用、能不能复用
2. 被复用模块的实际行为必须和承诺的职责相一致，这样才能被可靠地复用

### 第 2 章 优质代码的内在特征

优质代码的内在特征：一致的编码风格、有意义的命名、简洁的行为实现、高内聚和低耦合的模块化结构、没有重复、没有多余的设计、具备自动化测试。

#### 一致的编码风格

风格一致是对代码最基本的要求。

我们通常以编程规范的形式约束编码风格。编程规范是一个团队对代码风格做的约定。要想有效实施编程规范，需要注意如下 3 个方面：

- 有成文的编程规范
- 团队成员对编程规范的约定有深刻的理解
- 编程规范是团队资产的一部分，会被刻意关注并持续演进

编程规范并不是一堆刻板的条文，而是最佳经验的总结，例如《阿里巴巴 Java 开发手册》。

#### 有意义的命名

好的命名能反映领域模型的概念，同时也是意图导向编程的重要基础。

为命名犯难不应该在编程的时候才发生，它应该被前移到问题分析阶段。命名困难的本质，是没有对业务概念建立正确的理解。

不好的命名等于是在给代码加密。

从业务视角而不是开发视角命名代码是程序员努力的方向。

面向设计意图进行命名优化，好的代码，应该让人读起来像在阅读文章一样。

把这种更接近业务语义的命名方式应用到接口定义上，就形成了一种更加有趣、也更加易用的接口定义方式，我们称之为流畅接口。

例如：

```java
Person person = new Person();
person.setName("name");
person.setGender(Gender.Female);
person.setAge(10);
```

比上述代码更流畅的是：

```java
Person person = Person.builder()
        .name("name")
        .gender(Gender.Female)
        .age(10)
        .build();
```

#### 简洁的行为

代码元素要尽量简短。这里的简短是指 “认知” 层面的简短。

从认知层面讲，类、方法各是一个抽象层级。当代码阅读者理解一个类的时候，更关心方法这个层级，对于方法是怎么实现的并不关心。只有当理解了一个方法的时候，查看的才是实现方法的代码行这个层级。

设定一个代码行数量的警戒值有助于编写更高质量的代码。之所以会有过长的方法，很多时候是因为在一个方法中做了太多事情。有意识地减少代码行(如抽取一个新方法)有助于发现不够内聚的设计，或者抽象层次不足等问题。

代码的表达要清晰，抽象层次要一致。

方法的实现复杂度要尽量低。计算机非常善于处理条件判断和循环逻辑，不过对人类来讲，条件语句和循环语句的组合及嵌套实在复杂，复杂了就容易出错

复杂的控制结构，是非常容易识别的代码坏味道。一旦识别出这种问题，就需要关注控制结构的业务逻辑，重新组织代码结构，如提取方法或者进行抽象，以获得更为简短的代码。

#### 高内聚和低耦合的结构

模块化就是提升代码可理解性、可演进性、可复用性的关键。从设计层面看，模块化分解的最高指导原 则是高内聚，模块间协作的最高指导原则是低耦合。

内聚反映了设计单元内部的相关性。高内聚描述了一个代码元素边界内内容的紧密程度。

耦合则是设计单元之间相关性的表征。如果两个设计单元之间存在某种关系，使得当一个设计单元发生变化或者出现故障时，另外一个设计单元也会受到影响，那我们就说这二者之间存在耦合。

四种依赖形态对耦合的影响：

1. 循环依赖造成紧耦合，循环依赖往往意味着设计不合理，或者依赖粒度过大
2. 依赖层级越深，耦合越紧
3. 依赖范围越广，耦合越严重
4. 全局依赖和隐式依赖让耦合难以管理
5. 对内部状态和数据的依赖是严重的耦合，除了纯粹的数据类，都应该尽量少暴露 `getter`/`setter`方法。当一个对象对外暴露了 `getter`/ `setter` 方法时，很容易引入不必要的对内部状态和数据的依赖

#### 没有重复

重复是一种特殊的耦合。

- 重复代码增加了理解难度。重复代码增加了代码量，也增加了阅读代码的工作量，微小的不同容易被忽视，导致错误的引入。
- 重复代码加大了维护难度。如果重复代码中存在缺陷，那么很可能需要逐一修复每个重复实例。
- 重复代码往往隐含着改善设计的空间

DRY (Don't Repeat Yourself)原则，不要重复你自己。在一个系统中，每一块知识的表达，都应该是唯一、无歧义和权威的。

#### 没有多余的设计

对于软件设计而言，代码绝非越多越好，每一行代码在写出来之后，都意味着在未来会有理解成本和维护成本。**如果一些代码没有存在的道理和价值，它就不应该存在，或者应该被及时移除**。

造成多余的原因：

- 刻板地遵循某种设计范例
- 代码曾经有用，但是后来变得无用。一次次阅读这些已经无用的代码，是一种不必要的成本，应该把它们及时删除。
- 为未来预留了实现或者扩展。应该编写具有高度适应性的代码 ，而不是预先假定代码在未来的演进方向。因为代码具有适应性，所以一旦有新的功能需求，总是能比较容易地适配。

#### 具备自动化测试

自动化测试的价值远远不止“质量保障”那么简单，它几乎和优质代码的每一个外部属性 紧密相关。

**保证更能正确**：自动化测试

**提升代码可理解性**：面对一段陌生的代码时，可以先看一下是否存在自动化测试代码。如果存在，可以先不看产品代码，甚至不看产品文档，而是直接开始阅读测试代码。这是一个非常有效的技巧，之所以有效，是因为:编写良好的自动化测试代码，是最好的产品文档。测试能够始终保持和代码同步，这是一个非常重要的优势。

**保障软件系统的持续演进**：如果有完备的自动化测试， 那么只要一个命令，执行一下所有的自动化测试，哪些功能失败就一目了然了。所以，自动化测试是重构的防护网，在支持新功能时保护既有功能不被破坏。

**用契约和资产的观点看待自动化测试**：自动化测试代码和产品代码具备同等重要的地位，它也是软件资产的一部分。**测试的本质绝不仅是“测试”，它更本质的属性是“契约”**。

## 专业篇 建立扎实功底

### 高质量的需求

真正专业的程序员，会积极地投入到需求活动中，而不只是被动地接收来自产品经理或需求分析师的需求输出。

在 “正确地做事”和“做正确的事”中，“做正确的事”更加重要。

实践一再证明:在一个项目中，如果程序员没有积极投入到需求活动中，而只是被动地接收需求进行开发，那么往往会错漏百出，即使产品经理或需求分析师的能力很强，也无法改变这个结果。

#### 用结构化的方法分析需求

需求工程定义的三大活动：

- 需求获取: 正确地捕获业务方的诉求，对应达到的结果建立正确的预期；
- 需求分析和定义: 把业务方的诉求成功转换为对软件系统的需求，并进行清晰的表述；
- 需求澄清和确认：让相关涉众(如开发人员和测试人员)都正确理解需求，并达成一致；

需求分析的核心是探索和发现: 通过持续探索，发现并确立真正的业务目标，从而设计出真正合理的方案，包括系统需求、操作步骤和业务规则等。

在需求分析过程中一个常见的问题是: 基本的问题尚未真正得到澄清，就匆忙开始了关于细节的讨论。可想而知，在业务目标、业务流程没有被正确理解时，过多地讨论细节只会偏离正确的方向，掩盖真正的问题。

从业务目标到系统需求并不是一蹴而就的，联系它们的纽带是业务流程。业务流程聚焦于业务活动中的主体如何通过一系列业务活动交互，最终达成业务目标。系统功能是整个业务流程的一部分。

#### 探索业务流程，定义系统功能

UML 非常庞大，如果抱着“先学会再应用”的想法，那应用基本上就遥遥无期了。

直接开始使用 UML 就可以了，用到什么再学习什么。你会发现，只要使用 UML 大约 5% 的能力，就足以满足日常所需。在讨论和使用一个工具时，不应该脱离它的本质。以沟通为目的、 仅仅使用 UML 特征的有限子集来建模的方式，称为注重实效的 UML。

相对于软件建模工具，手绘的草图更适合用于思考和沟通。

有好几种 UML 图都适用于需求建模，这里列举三种：

- 用例图：表达系统有哪些功能，执行者会使用系统的哪些功能
- 顺序图：表达参与者如何彼此交互，完成一个功能或业务
- 活动图：表达一个功能或业务设计的活动或流程
